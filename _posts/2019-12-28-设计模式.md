---
layout: post
title: 设计模式
category: 碎笔
tag: [设计模式]
# permalink: /notes/category/碎笔/设计模式
permalink: /Title::title
---
设计面向对象的软件是比较困难的，而设计可复用的面对对象的软件就更困难。所以我们必须
对手头上的问题有一定的针对性，必须要找到相关的对象以适当的粒度将它们归类，再定义类
的接口和继承层次来建立对象之间的基本关系，同时对未来可能的问题和需求也要有足够的通
用性。

人们在面对这些问题时，不是每次解决问题都要从头做起。人们更愿意复用以前使用过的解决
方案。当找到一个好的解决方案时，人们会一遍又一遍地使用。这些经验成为了后来我们所说
的设计模式。这些模式解决特定的的设计问题，使面向对象的设计更灵活、优雅，最终复用性
更好。

#### 什么是设计模式
Christopher Alexander说过：“每一个模式描述了一个在我们周围不断重复的问题，以及该问
题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复的劳动。”

#### 设计模式编目

| 设计模式名 | 中译名 | 描述 |
| ------ | -------- | ------ |
| <span id="dp-1">Abstract Factory</span> | 抽象工厂 | 提供一个创建一系列相关或相互依赖的对象的接口，而无需指定它们的具体类。 |
| Adapter | 适配器 | 将一个类的接口转换成客户希望的另外一个接口。`Adapter` 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 |
| Bridge | 桥接 | 将抽象部分与它的实现部分分享，使它们都可以独立变化。 |
| Builder | 生成器 | 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 |
| Chain of Responsibility | 职责链 | 为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连接成一条链，并沿着这条链传递该请求，直到有一个对象处理它。 |
| Command | 命令 | 将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。|
| Composite | 组成 | 将对象组合成树形结构以表示 “部分-整体” 的层次结构。`Composite` 使得客户对单个对象和复合对象的使用具有一致性。|
| Decorator | 装饰 |动态地给一个对象添加一些额外的职责。就扩展功能而言，`Decorator` 模式比生成子类方式更为灵活。|
| Facade | 外观 | 为子系统中的一个组接口提供一个一致的界面，`Facade` 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 |
| Factory Method | 工厂方法 | 定义一个用于创建对象的接口，让子类决定将哪一个类实例化。`Factory Method` 使一个类的实例化延迟到其子类。 |
| Fyweight || 运用共享技术有效地支持大量细粒度的对象。 |
| Interpreter | 解释器 | 给定一个语言，定义它的方法和一种表示 ，度定义一个解释器，该解释器使用该表示来解释语言中的句子。 |
| Iterator | 迭代器 | 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要爆露该对象的内部表示 。 |
| Mediator | 中介者 | 用一个中介对象来封装一系列的对象交互。中介者使对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们宰的交互。 |
| Memento | 备忘录 | 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到保存的状态。 |
| Observer | 观察者 | 定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时所有依赖于它的对象都得到通知并自动刷新。 |
| Prototype | 原型 | 用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。 |
| Proxy | 代理 | 为其它对象提供一个代理以控制对这个对象的访问。 |
| Singleton | 单例 | 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 |
| State | 状态 | 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。 |
| Strategy | 策略 | 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于命名用它的客户。 |
| Template Method | 模板方法 | 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。`Template Method` 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定上步骤。 |
| Visitor | 访问者 | 表示一个作用于某个对象结构中的各个元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 |

#### 组织编目
由于存在众多的设计模式，而且设计模式在粒度和抽象层次上各不相同，我们希望用一种方式将它们组织起来。对设计模式进行分类以便于我们对种族相关的模式进行引用。

||||目的||
|-|-|-|-|-|
|||创建型|结构型|行为型|
|范围|类|Factory Method|Adapter(类)|Interpreter<br>Template Method|
||对象|Abstract Factory<br>Builder<br>Prototype<br>Singleton|Adapter(对象)<br>Bridge<br>Composite<br>Decorator<br>Facade<br>Flyweight<br>Proxy|Chain of Responsibility<br>Command<br>Iterator<br>Mediator<br>Memento<br>Observer<br>State<br>Strategy<br>Visitor|

#### 针对一些问题，解决这些问题的设计模式
1、**通过显示地指定一个类来创建对象：** 在创建对象时指定类名将使你受特定实现的约束而不是特定接口的约束。这会使未来更复杂。要避免这种情况，应该间接地创建对象。
**设计模式：** Abstract Factory, Factory Method, Prototype。

2、**对特殊操作的依赖：** 当你为请求指定一个特殊的操作时，完成该请求的方式就固定下来了。为了避免把请求代码写死，你将可以在编译时刻或运行时刻很方便地改变响应请求的方法。
**设计模式：** Chain of Resposibility, Command。

3、**对硬件和软件不台的依赖：** 外部的操作系统接口和应用编程接口（API）在不同的软件硬件平上是不同的。依赖于特定平台的软件将很难移植到其他平台上，甚至都很难跟上本地平台的更新。所以设计系统时限制其平台相关性就很重要了。
**设计模式：** Abstract Factory, Bridge。

4、**对对象表示或实现的依赖：** 知道对象怎样表示、保存、定位或实现的客户在对象发生变化时可能也需要变化。对客户隐藏这些信息能阻止连锁变化。
**设计模式：** Abstract Factory, Bridge, Memento, Proxy。

5、**算法依赖：** 算法在开发和复用时常常扩展、优化和替代。依赖于某个特定算法的对象的算法发生变化时不得不变化。因此有可能发生变化的算法应该被孤立起来。
**设计模式：** Builder, Iterator, Strategy, Template Method。

6、**紧耦合：** 紧耦合的类很难独立地被复用，因为它们是互相依赖的。紧耦合产生单块的系统，要改变或删掉一个类，你必须理解和改变其他许多类。这样的系统是一个很难学习的、移植和维护的密集集体。
松散耦合提高了一个类本身被复用的可能性，并且系统更易于学习、移植、修改和扩展。设计模式使用抽象耦合和分层技术提高系统的松散耦合性。
**设计模式：** Abstract Factory, Command, Facade, Mediator, Observer, Chain of Responsibility。

7、**通过生成子类来扩充功能：** 通常很难通过定义子类来定制对象。每一个新类都有固定的实现开销（初始化、终止处理等）。定义子类还需要对父类有深入的了解。如，重定义一个操作可能需要重定义其他操作。一个被重定义的操作可能需要调用继承下来的操作。并且子类方法导致类爆炸，因为即使对于一个简单的扩充，你也不得不引入许多新的子类。
一般的对象组合技术和具体的委托技术，是继承之外组合对象行为的另一种灵活方法。新的功能可以通过以新的方式组合已有对象，而不是通过定义已存在类的子类的方式加到应用中。另一方法，过多使用对象组合会使设计难于理解。许多设计模式产生的设计中，你可以定义一个子类，且将它的实例和已存在实例进行组合来引入定制的功能。
**设计模式：** Bridge, Chain of Responsibility, Composite, Decorator, Observer, Strategy。

8、**不能方便地对类进行修改：** 有时你不得不改变一个难以修改的类。也许你需要源代码而又没有（对于商业类库就有这种情况），或者可能对类的任何改变会要求修改已存在的其他子类。设计模式提供这些情况下对类进行修改的方法。
**设计模式：** Adapter, Dcorator, Visitor。

#### 设计模式所支持的设计的可变方面

|目的|设计模式|可变的方面|
|-|-|-|
|创建|Abstract Factory|产品对象家庭|
||Builder|如何创建一个组合对象|
||Factory Method|被实例化的子类|
||Prototype|被实例化的类|
||Singleton|一个类的唯一实例|
|结构|Adapter|对象的接口|
||Bridge|对象的实现|
||Componsite|一个对象的结构和组成|
||Decorator|对象的职责，不生成子类|
||Facade|一个子系统的接口|
||Flyweight|对象的存储开销|
||Proxy|如何访问一个对象；该对象的位置|
|行为|Chain of Responsibility|满足一个请求的对象|
||Command|何时、怎样满足一个请求|
||Interpreter|一个语言的方法及解释|
||Iterator|如何遍历、访问一个聚合的各元素|
||Mediator|对象间怎样交互、和谁交互|
||Memento|一个对象中哪些私有信息存放在该对象之外，以及在什么时候进行存储|
||Observer|多个对象依赖说另一个对象，而这些对象又如何保持一致|
||State|对象的状态|
||Strategy|算法|
||Template Method|算法中的某些步骤|
||Visitor|某些可作用于一个（组）对象上的操作，但不修改这些对象的类|
